[ { "title": "驱动外挂的原理及检测手段", "url": "/posts/The-principle-and-detection-method-of-driver-cheat/", "categories": "Tutorials, Driver Cheat", "tags": "tutorials, driver cheat, ring0", "date": "2020-07-13 12:40:00 +0800", "snippet": "因为PatchGuard技术的存在导致游戏在驱动层的保护不能像以前那样通过SSDT Hook或者IDT Hook来做了,游戏厂家不能擅自关闭PatchGuard来强行Hook.这样留给驱动挂的空间就很大了我将以一个 自瞄挂的原理 为例子展示驱动外挂的几种实现方式及检测手段相同的驱动获取及控制手段要想实现 自瞄驱动挂 基本上都是读取游戏数据然后直接操作鼠标,不同之处就是操纵鼠标的方式下面是所有驱动挂的几个相同之处相同点1 - 获取鼠标的驱动对象一个自瞄驱动挂的实现首先必然需要获得鼠标的驱动对象,在任何驱动挂里应该都是一样的可以通过ObReferenceObjectByName来获取鼠标驱动..." }, { "title": "cheatlib中函数钩子模块的原理", "url": "/posts/The-principle-of-function-hook-module-in-cheatlib/", "categories": "Tutorials, Function Hook", "tags": "tutorials, function hook, cheatlib", "date": "2020-07-04 12:40:00 +0800", "snippet": "点此查看cheatlib全部源代码函数钩子的原理函数钩子本质上劫持函数调用让一个函数执行前先去执行我们的函数然后在我们的函数里决定是否要执行源函数本质上就是在函数头写一个jmp指令直接跳到我们的函数.因为参数已经压栈所以我们的函数定义要保证和被Hook函数的定义保持一致在某些外挂的应用下一般而言会写在dll里然后注入到目标程序里去替换对应函数为自己dll中的函数,下面我将介绍这种方法的原理实现原理FuncHook/* 说明: 将pOrigAddr处的函数直接替换为pHookAddr处的函数执行* 注意: pOrigAddr和pHookAddr处的函数定义必须一致* 此函..." }, { "title": "iTruth整合版x64dbg(最新中文版) 内置配色方案+插件", "url": "/posts/iTruth-personal-integrated-x64dbg/", "categories": "Tool, x64dbg", "tags": "x64dbg, debugger, debug, tools", "date": "2020-05-16 22:36:00 +0800", "snippet": "包含个人仿吾爱OD的配色包含的拓展功能 包含两款反反调试插件(ScyllaHide和SharpOD), 轻松过掉各大程序的反调试 两款脱壳插件(OllyDumpEx_X64Dbg和Scylla) 中文搜索支持(x64dbg_tol) 类似IDA的F5反汇编至C++代码(snowman) API断点插件(x64dbgApiBreak) 自动调试子进程(DbgChild) 类似CE的内存搜索(ClawSearch) PE头浏览支持(peviewer) 提取PE头信息(PEHeaderDumpUtilities) 程序伪调试支持(NaiHeQiao) 非侵入式调试支持(G..." } ]
